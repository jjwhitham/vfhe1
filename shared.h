#pragma once

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <chrono>
#include "gmpxx.h"

typedef mpz_class bigz;
typedef long int u32; // FIXME - why signed? Rationalise usage across code
u32 N_DECOMP = 2;
constexpr size_t N_ = 4096;

#ifdef TIMING_ON
#  define TIMING(x) x
#else
#  define TIMING(x)
#endif

typedef struct {
    int calls_ntt = 0;
    int calls_intt = 0;
    int calls_ntt1 = 0;
    int calls_intt1 = 0;
    int calls_conv_to_nega = 0;
    int calls_get_hash_sec = 0;
    int iter_ = 0;
    std::chrono::duration<double, std::milli> verify{};
    std::chrono::duration<double, std::milli> proof{};
    std::chrono::duration<double, std::milli> controller{};
    std::chrono::duration<double, std::milli> plant{};
    std::chrono::duration<double, std::milli> total{};
    std::chrono::duration<double, std::milli> loop{};
    std::chrono::duration<double, std::milli> ntt{};
    std::chrono::duration<double, std::milli> intt{};
    std::chrono::duration<double, std::milli> ntt1{};
    std::chrono::duration<double, std::milli> intt1{};
    std::chrono::duration<double, std::milli> get_hash_sec{};
} times_and_counts;

// NOTE inline keyword for structs allows the struct to be used in multiple
// translation units without causing linker errors
inline times_and_counts timing = { 0 };

// constexpr bigz N_ = 2;
// constexpr bigz GROUP_MODULUS = 11; // p
// constexpr bigz FIELD_MODULUS = 5; // q
// constexpr bigz GENERATOR = 4; // g

// q_pow = 30.000011008191272;
// constexpr bigz N_ = 4096;
// constexpr bigz GROUP_MODULUS = 17180000273;
// constexpr bigz FIELD_MODULUS = 1073750017;
// constexpr bigz GENERATOR = 65536;
// constexpr bigz NTH_ROU = 625534531;
// constexpr bigz TWO_ROU = 996876704;

// constexpr bigz N_ = 8;
// constexpr bigz GROUP_MODULUS = 103;
// constexpr bigz FIELD_MODULUS = 17;
// constexpr bigz GENERATOR = 64;
// constexpr bigz NTH_ROU = 3;
// constexpr bigz TWO_ROU = 9;

// N = 2^12, log q = 54.00000000000197 (55 bit prime)
bigz GROUP_MODULUS = 540431955285196831;
bigz GENERATOR = 1073741824;
bigz FIELD_MODULUS = 18014398509506561;
bigz NTH_ROU = 5194839201355896;
bigz TWO_ROU = 9455140237568613;
/*
bigz GROUP_MODULUS("898846567431158003760658660800415388695860588403194539336418\
3815501945595841537012838580057296239271804947467115111499650941742633115916727\
4173985578890984435612970736081155406155170101580895226642186535601576839882976\
8772042832628185349382795294302615514942250653305359248181354706753938688250603\
16220145843");
bigz GENERATOR("4516690346444892428005324399985509466774242146852912703800039069\
0990555413931211221819477288776566894331153249407833821645949924742511460070046\
0752019004410401310119718077614657859287173286718671972587346128683743555111219\
5974661753294711265189310135666066227878669003666163196105068185398215987576405\
0554114");
*/



// 3072 bit p, 256 bit q

// q = 21888242871839275222246405745257275088548364400416034343698204186575808495617
// p = 4392772178269698779249497429153895261004854964304840660916201900668102392172522175350668394664935750259347812130183944879351355906518926632830329330496131989727231502710296460492164287318375786336907987767626799125327636934265658399742198412342719090057086168880889712839197400387724670989586460157194363980194764268264125313301073396188143254907615446127440745152020903788479338857344361899447199054227989638896540596311854055403871612021661745083159598567756761035975656516547560556799103409070694389876327888755482633655220784287105807917527574669465932781674094138315575558417923729225658787727802339009076757523927501640307172875293525893384503441199138850260123305115711729066850257587831231912669311414294512065668993622106043812820824371263469683358771042012208642778598479107222917932135034026454638522538138974113816154782399605206089212477531918299674320244010733640448697722371484336761343601982747862276199417869
// g = 882374229418829764080485409545757713898799631881227679986577048440494362215606850660141321495110804218009771399350882382666425182658799215263796398020127921532598817785159844219314319798858780543520300210324574291390921835922872833005091925021096648305665685079523101841404165276223794685719362821943593295872103831531572945249008882331185778814112205151387556553998492449584873517191590453316730902139509091322170827465685754402718869685086896626332187392554923084662707326358199258372989439552933754177374023527476200431371087222573254234577589115232366908032292917644227921461814717680917768403178393439975736207106151457402925730230329880490733847413881464632949011882487564218937408222407754831468379028324895219097733670214564567757552604483198029212049987903341212112504505022828696364531302823008465369763316441950245447742998997259091356093277431906882201308703759347411984397224575118527345082058198658774438895353
// root_nth = 4158865282786404163413953114870269622875596290766033564087307867933865333818
// root_nth_inv = 12199007973319674300030596965685270475268514105269206407619072166392043015767
// root_2nth = 197302210312744933010843010704445784068657690384188106020011018676818793232
// root_2nth_inv = 10150407646632095964976043332470470774111901718625076075560248572110916115913

/*
bigz NTH_ROU("4158865282786404163413953114870269622875596290766033564087307867933865333818");
bigz TWO_ROU("197302210312744933010843010704445784068657690384188106020011018676818793232");

bigz FIELD_MODULUS("\
21888242871839275222246405745257275088548364400416034343698204186575808495617\
");

bigz GROUP_MODULUS("\
4392772178269698779249497429153895261004854964304840660916201900668102392172522\
1753506683946649357502593478121301839448793513559065189266328303293304961319897\
2723150271029646049216428731837578633690798776762679912532763693426565839974219\
8412342719090057086168880889712839197400387724670989586460157194363980194764268\
2641253133010733961881432549076154461274407451520209037884793388573443618994471\
9905422798963889654059631185405540387161202166174508315959856775676103597565651\
6547560556799103409070694389876327888755482633655220784287105807917527574669465\
9327816740941383155755584179237292256587877278023390090767575239275016403071728\
7529352589338450344119913885026012330511571172906685025758783123191266931141429\
4512065668993622106043812820824371263469683358771042012208642778598479107222917\
9321350340264546385225381389741138161547823996052060892124775319182996743202440\
10733640448697722371484336761343601982747862276199417869\
");

bigz GENERATOR("\
8823742294188297640804854095457577138987996318812276799865770484404943622156068\
5066014132149511080421800977139935088238266642518265879921526379639802012792153\
2598817785159844219314319798858780543520300210324574291390921835922872833005091\
9250210966483056656850795231018414041652762237946857193628219435932958721038315\
3157294524900888233118577881411220515138755655399849244958487351719159045331673\
0902139509091322170827465685754402718869685086896626332187392554923084662707326\
3581992583729894395529337541773740235274762004313710872225732542345775891152323\
6690803229291764422792146181471768091776840317839343997573620710615145740292573\
0230329880490733847413881464632949011882487564218937408222407754831468379028324\
8952190977336702145645677575526044831980292120499879033412121125045050228286963\
6453130282300846536976331644195024544774299899725909135609327743190688220130870\
3759347411984397224575118527345082058198658774438895353\
");
*/



/*
// 1152 bit p,  128 bit q
bigz GROUP_MODULUS("\
4893786199427765557762591497536453196573320618411278635472176938119840441271\
2502191283384375987166735470567071036504573974100823080776092800473413359198247\
6239041963014833898372354040701042388893258698981186938413740280916319621417623\
7471114636814326740929854005470025012660047589916149139703043020351672528846339\
84145576703811773398576717571852999");
bigz FIELD_MODULUS("340282366920938463463374607431767867393");
bigz GENERATOR("\
4817716213549514035336014710666703183713025673847494424413528199993357208789\
8913394575489847649253866038828334491235671772417871456974026431473237742550247\
9497578100053448330287050686965459146273651762955474911950522760806904335945868\
4003625854903563191461961625964949673337592873574451932801584164249941551882456\
08741421710111223106441384922396297");
*/

size_t N_POLYS_IN_RLWE = 2;
using matrix_double = std::vector<std::vector<mpf_class>>;
using vector_double = std::vector<mpf_class>;
using vector_bigz = std::vector<bigz>;

// FIXME make types __uint128 so that regular modding works
bigz& mod_(bigz& val, const bigz& q) {
    // bigz ret(val);
    val %= q;
    // if (val < 0) {
    //     val += q;
    // }
    return val;
}

std::string i128str(__uint128_t n) {
    if (n == 0) {
        return "0";
    }
    // bool neg = false;
    // if (n < 0) {
    //     neg = true;
    //     n = -n;
    // }
    std::string buf;
    while (n > 0) {
        buf += '0' + (n % 10);
        n /= 10;
    }
    // if (neg) buf += '-';
    std::reverse(buf.begin(), buf.end());
    return buf;
}
vector_bigz scalar_vec_mult(const bigz& scalar, const vector_bigz& vec, const bigz& q) {
    vector_bigz result(vec.size());
    for (size_t i = 0; i < vec.size(); i++) {
        // copy vec
        result[i] = scalar * bigz(vec[i]);
        result[i] = mod_(result[i], q);
    }
    return result;
};

void print_vector_i128(const std::vector<__uint128_t>& vec) {
    for (const auto& val : vec) {
        std::cout << i128str(val) << ", ";
    }
    std::cout << "\n";
}

void print_vector_double_old(const std::vector<double>& vec) {
    for (const auto& val : vec) {
        std::cout << val << ", ";
    }
    std::cout << "\n";
}

char* mpf_str(mpf_class m) {
    int size = 10000;
    char* buf = new char[size];
    buf[size - 1] = '\0';
    int ret = gmp_sprintf(buf, "%Zd", m.get_mpf_t());
    if (ret > size - 1 || ret < 0) {
        throw std::runtime_error("Buffer overflow in mpf_str");
    }
    return buf;
}

void print_vector_double(const vector_double& vec) {
    for (const auto& val : vec) {
        std::cout << mpf_str(val) << ", ";
    }
    std::cout << "\n";
}

char* print_to_string_mpz(bigz m) {
    int size = 10000;
    char* buf = new char[size];
    buf[size - 1] = '\0';
    int ret = gmp_sprintf(buf, "%Zd", m.get_mpz_t());
    if (ret > size - 1 || ret < 0) {
        throw std::runtime_error("Buffer overflow in print_to_string_mpz");
    }
    return buf;
}

void print_vector_mpz(const vector_bigz& vec) {
    for (const auto& val : vec) {
        std::cout << print_to_string_mpz(val) << ", ";
    }
    std::cout << "\n";
}
// TODO types and move somewhere
// Returns floor(log2(x))
double log2_mpz(const bigz& x) {
    if (x == 0) return -1; // or throw/handle as needed
    return static_cast<double>(mpz_sizeinbase(x.get_mpz_t(), 2) - 1);
}

mpf_class mpf_round(const mpf_class &x) {
    const mpf_class half("-0.5");
    if (x >= -1)
        return floor(x + half);   // correct for non-negative values
    else
        return ceil(x - half);    // correct for negative values
}

// base case binary modular exponentiation
bigz pow_(bigz base, bigz power, bigz mod) {
    bigz result = 1;
    // TODO should we just mutate base?
    mpz_powm(result.get_mpz_t(), base.get_mpz_t(), power.get_mpz_t(), mod.get_mpz_t());
    return result;
}